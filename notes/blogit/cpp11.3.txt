Here's 

<h2>throw() as noexcept equivalent</h2>

throw() without any exception types can be used as an equivalent to the new noexcept keyword.  Stroustrup also mentions that explicit throw() clauses 

[sourcecode language="cpp"]
void foo() throw( e1, e2 ) ;
[/sourcecode]

haven't worked out well in practise, and is deprecated.

<h2>try scopes as function body</h2>

It turns out that try clauses can be used as function bodies, as in

[sourcecode language="cpp"]
void foo( void )
try {
}
catch ( ... )
{
}
[/sourcecode]

This can also be done for constructor and destructor bodies as in

[sourcecode language="cpp"]
X::X( T1 v, T2 w )
try{
 : f1( v )
 , f2( w )
}
catch ( ... )
{
}
[/sourcecode]

so that a throw in the class field member construction can also be caught.

<h2>Inline (default) namespace</h2>

There is a mechanism for namespace versioning.  Suppose that you want a new V2 namespace to be the default, you can do:

[sourcecode language="cpp"]
namespace myproject
{
   inline namespace V2
   {
      struct X { 
         int x ;
         int y ;
      } ;
      void foo( const X & ) ;
   } 

   namespace V1
   {
      struct X { 
         int x ;
      } ;

      void foo( const X & ) ;
   } 
} 
[/sourcecode]

Existing callers of the library that are using V1 interfaces can continue to work unmodified, but new callers will use the V2::X and V2::foo interfaces, and the library can provide both interfaces, one for compatibility and another for new code:

[sourcecode language="cpp"]
void myproject::V2::foo( const myproject::V2::X & )
{
   // ...
}

void myproject::V1::foo( const myproject::V1::X & )
{
   // ...
}
[/sourcecode]

<h2>Unnamed namespaces.</h2>

<h2>at_quick_exit</h2>

There's now also a mechanism to exit and avoid global destructors and atexit routines from being evaluated.  Here's an example

[sourcecode language="cpp"]
#include <cstdlib>
#include <iostream>

extern "C"
void normalexit()
{
   std::cout << "normalexit\n" ;
}

extern "C"
void quickCexit()
{
   std::cout << "quickCexit\n" ;
}

void quickCPPexit()
{
   std::cout << "quickCPPexit\n" ;
}

class X
{
public:
   ~X()
   {
      std::cout << "X::~X()\n" ;
   }
} x ;

int main( int argc, char ** argv )
{
   atexit( normalexit ) ;
   std::at_quick_exit( quickCexit ) ;
   std::at_quick_exit( quickCPPexit ) ;

   if ( argc == 1 )
   {
      std::quick_exit( 3 ) ;
   }

when run without arguments (argc == 1), we get
[sourcecode language="bash"]
$ ./at
quickCPPexit
quickCexit
[/sourcecode]

whereas if the normal exit processing is allowed to complete we see global destructors and regular atexit calls
[sourcecode language="bash"]
$ ./at 1
normalexit
X::~X()
[/sourcecode]

Observe, unlike atexit, which can only (portably) take extern "C" defined functions, at_quick_exit can take functions with both C and C++ linkage.
XX
<h2>Enum default</h2>

It was not obvious to me what the default value for an enum class (or enum) should be (the first value, an invalid value, zero, ...)?  It turns out that the default is zero, as printed by the following fragment

[sourcecode language="cpp"]
#include <iostream>

enum class x { v = 1, w } ;
enum y { vv = 1, ww } ;

int main()
{
   x e1 = {} ;
   y e2 = {} ;
   std::cout << (int)e1 << '\n' ;
   std::cout << e2 << '\n' ;

   return 0 ;
}
[/sourcecode]

Note that an explicit cast is required for enum class values, but not for enum, which are by default, int convertable.

<h2></h2>
<h2></h2>

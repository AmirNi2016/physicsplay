#! /usr/bin/perl
# $Log: tex2blog,v $
# Revision 1.15  2009/09/18 01:42:56  Peeter
# got some of the latex2mathml changes made.  Going to revamp the
# main loop to slurp it all in and use multiline patterns.
#
# Revision 1.14  2009/09/17 02:04:41  Peeter
# *** empty log message ***
#
# Revision 1.13  2009/09/13 03:26:46  Peeter
# *** empty log message ***
#
# Revision 1.12  2009/08/29 19:08:31  Peeter
# *** empty log message ***
#
# Revision 1.11  2009/08/09 04:43:49  Peeter
# *** empty log message ***
#
# Revision 1.10  2009/07/11 04:53:16  Peeter
# *** empty log message ***
#
# Revision 1.9  2009/07/09 03:17:51  Peeter
# *** empty log message ***
#

use strict ;
use warnings ;
use Getopt::Long;

my $filebase ;
#my $showNumbers = 1 ;

# blogger or wordpress?
my $blogger = 0 ; 
my $mathml = 1 ; 
my $mathmlHtml = 1 ; 

GetOptions( 
   'blogger!'  => \$blogger,
   'mathml!'   => \$mathml,
   'file=s'    => \$filebase,
#   'num!'      => \$showNumbers,
) ;

if ( $blogger or $mathmlHtml )
{
   $mathml = 1 ;
}

my $latexDollarStart ;

if ( $mathml )
{
   $latexDollarStart = '$' ;
#   $showNumbers = 0 ;
}
else
{
   $latexDollarStart = '$latex ' ;
}

my $fh ;
my %equations ;

#foreach (<light*>)
#{
#print "$_\n" ;
#}
#my $pwd = `pwd` ; chomp $pwd ;
#print "pwd: $pwd\n" ;

open $fh, "<$filebase.aux" or die "could not open '$filebase.aux'\n" ;
while (<$fh>)
{
   if ( /^\\newlabel{(.*?)}.*equation\.(.*?)}/ )
   {
      $equations{$1} = $2 ;
   }
}
close $fh ;

my $bibString = '' ;
my %refnumbers ;
my $curNum = 1 ;
my $haveBib = 1 ;
open $fh, "<$filebase.bbl" or $haveBib = 0 ;

if ( $haveBib )
{
   while (<$fh>)
   {
      chomp ;

      s,\\begin{thebibliography}.*,<h1>References</h1>, ;

#\bibitem[Joot({\natexlab{a}})]{PJLorentzWave}
      s/\\bibitem.*]{/\\bibitem{/ ;
      if ( s/\\bibitem{(.*?)}// )
      {
         $bibString .= "\n\n" ;
         $refnumbers{$1} = $curNum ;
         $bibString .= "[$curNum] " ;

         $curNum++ ;
      }
      else
      {
         next if (/Available from:/ or
                  /\\providecommand/ or
                  /\\expandafter/ or
                  0 ) ;

         if ( /\\end{thebibliography}/ )
         {
            $bibString =~ s,\\url{(.*?)},<a href="$1">$1</a>,;
            $bibString .= "\n" ;
            last ;
         }

         s/~/ /g ;
         s,{ *\\em\s+(.*?)},<em>$1</em>,g;
         s,\\em *{(.*?)},<em>$1</em>,g ;
         s,\\emph *{(.*?)},<em>$1</em>,g ;
         s/\\newblock// ;

# \url can be split across lines, as in the following:
#  \url{http://en.wikipedia.org/w/index.php?title=Relativistic_Doppler_effect&o%
#ldid=298724264}.
#
#In case it isn't do a first check here before stripping out {}'s
#
         s,\\url{(.*?)},<a href="$1">$1</a>,sg;
         s/{(.*?)}/$1/g ;

#die "'$_'\n" if /\\url/ ;
         $bibString .= "$_" ;
      }
   }

   close $fh ;
}

my $curEqn = '' ;
my $curEquationLabel = '' ;
my $inEquation = 0 ;
my $failedOpen ;
#my $urlMessage = "Click here for a PDF of this post with nicer formatting" ;
my $urlMessage = "Click here for a PDF of this sequence of posts with nicer formatting" ;

my $allOut = '' ;

if ( $mathmlHtml )
{
$allOut .= qq(
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 //EN" 
    "http://www.w3.org/TR/REC-html40/strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
		
<head>
<title>blah</title>
<script type="text/javascript" src="http://math.etsu.edu/LaTeXMathML/LaTeXMathML.js"></script>
<link rel="stylesheet" type="text/css" href="http://math.etsu.edu/LaTeXMathML/LaTeXMathML.standardarticle.css" />
</head>
) ;
}

if ( $mathml )
{
   $allOut .= qq(<pre class="LaTeX"><div>\n) ;
}

open $fh, "<$filebase.tex" or $failedOpen = 1 ;
if ( $failedOpen )
{
   open $fh, "<$filebase.ltx" or die "could not open '$filebase.tex' nor '$filebase.ltx'\n" ;
}

my $eqnArray ;
my $newLineEqn = '' ;

#if ( $mathml )
#{
#   $newLineEqn = "\n" ;
#}

while (<$fh>)
{
   chomp ;
   s/\\chapcite{(.*?)}/[$refnumbers{$1}]/g;
   s/\\cite{(.*?)}/[$refnumbers{$1}]/g;
   s/%.*//;
   s,\\blogpage{(.*)},<a href="$1">[$urlMessage]</a>,;

next if (
/\\begin{document}/ or
/\\end{document}/ or
/\\maketitle/ or
/\\tableofcontents/ or
/\\usepackage/ or
/\\newcommand/ or
/\\documentclass/ or
/\\title/ or
/\\email/ or
/\\date/ or
/\\author/ or
/\\revisionInfo/ or
/\\input/ or
/\\bibliography/ or
/\\beginArtWithToc/ or
/\\EndArticle/ or
/\\EndNoBibArticle/ or
/\\beginArtNoToc/ or
0 ) ;

   if ( !$mathml )
   {
      while ( s/\$(.*?)\$/BBB:$1:EEE/g )
      {
      }

      s/BBB:/\$latex /g;
      s/:EEE/\$/g;
   }

   if ( !$mathml )
   {
      s/\\ref{(eqn:.*?)}/$equations{$1}/g ;
   }

   s,\\section{(.*)},<h1>$1</h1>,;
   s,\\subsection{(.*)},<h2>$1</h2>,;
   s,\\subsubsection{(.*)},<h3>$1</h3>,;
   s,\\href{(.*?)}{(.*?)},<a href="$1">$2</a>,g ;

   if ( s/\\begin{align\**}// or s/\\begin{equation\**}// )
   {
      $eqnArray = "eqnarray*" ;

      if ( !$mathml and s/\\label{(eqn:.*?)}// )
      {
         $curEquationLabel = "\\quad\\quad\\quad($equations{$1})" ;
      }
      elsif ( $mathml and /\\label{eqn:.*?}/ )
      {
         $eqnArray = "eqnarray" ;
      }

      $curEqn .= "$_$newLineEqn" ;
      $inEquation = 1 ;
   }
   elsif ( s/\\end{align\**}.*// or s/\\end{equation\**}.*// )
   {
      my $eq ;

      if ( $mathml )
      {
#<blockquote>$\begin{eqnarray}\nabla F &= J/{\epsilon_0} c \\ m\frac{d^2 X}{d\tau} &= \frac{q}{c} F \cdot \frac{dX}{d\tau}\end{eqnarray}$</blockquote>
#<blockquote>$\begin{eqnarray*}\nabla \cdot \mathbf{E} = \rho\end{eqnarray*}$</blockquote>

         $eq = '<blockquote>$\\begin{' . $eqnArray . '}' . translate( "$curEqn$_" ) ;

         # strip trailing \\ at the end of the equation:
         $eq =~ s/ *\\\\ *$//g;

         $eq .= " \\end{$eqnArray}\$</blockquote>\n" ;
      }
      else
      {
         # sample output from latex2wp.  centers things ... looks a bit nicer.
         #<p align=center>$latex \displaystyle   \forall g \in {\cal F}. g^2 = \eta \ \ \ \ \ (1)&fg=000000$</p>

         $eq = '<p align=center>$latex \\begin{aligned}' . translate( "$curEqn$_$newLineEqn" ) ;
         $eq =~ s/ *\\\\ *$//g;

         # latex2wp used this, but I don't see a difference:
         my $fgString = '' ;
         #      $fgString = "&fg=000000" ; # omit.

         $eq .= " \\end{aligned} $curEquationLabel$fgString\$</p>\n" ;
      }

      $allOut .= $eq ;
      $curEqn = '' ;
      $inEquation = 0 ;
      $curEquationLabel = '' ;
   }
   elsif ( $inEquation )
   {
      $curEqn .= "$_$newLineEqn" ;
   }
   else
   {
      s/\\label{(.*?)}//g;

      $allOut .= translate( $_ ) . "\n" ;
   }
}
close $fh ;

$allOut .= $bibString ;

# doesn't work just right.  Keep the post processing manual for now.
#$allOut =~ s/[\n\r\l]+/\n/smg ;
$allOut =~ s/[\r\l]+//smg ;

if ( $mathml )
{
   $allOut .= qq(\n</div></pre>) ;
}

if ( $mathmlHtml )
{
   $allOut .= qq(\n</body> </html>) ;
}

print $allOut ;

exit ;

sub translate
{
   my $r1 = qr/
        (                   # start of capture buffer 1
        {                   # match an opening angle bracket
            (?:               
                [^{}]++     # one or more non angle brackets, non backtracking
                  |                  
                (?1)        # found { or }, so recurse to capture buffer 1
            )*                 
        }                   # match a closing angle bracket
        )                   # end of capture buffer 1
        /x;

   my $r2 = qr/
        (                   # start of capture buffer 1
        {                   # match an opening angle bracket
            (?:               
                [^{}]++     # one or more non angle brackets, non backtracking
                  |                  
                (?1)        # found { or }, so recurse to capture buffer 1
            )*                 
        }                   # match a closing angle bracket
        )                   # end of capture buffer 1
        (                   # start of capture buffer 1
        {                   # match an opening angle bracket
            (?:               
                [^{}]++     # one or more non angle brackets, non backtracking
                  |                  
                (?1)        # found { or }, so recurse to capture buffer 1
            )*                 
        }                   # match a closing angle bracket
        )                   # end of capture buffer 1
        /x;


   my $out = "@_" ;

   $out =~ s/\\\\/\\\\ /g;
#   $out =~ s/&=/=/g;

   # convert some of my macros:
   #$out =~ s/\\inv{(.*?)}/\\frac{1}{$1}/g;
   $out =~ s/\\inv${r1}/\\frac{1}{$1}/g;
   #$out =~ s/\\Abs{(.*?)}/{\\left\\lvert{$1}\\right\\rvert}/g;
   $out =~ s/\\Abs${r1}/{\\left\\lvert$1\\right\\rvert}/g;
   $out =~ s/\\gpgrade${r2}/{\\left\\langle{$1}\\right\\rangle}_{$2}/g;

#   $out =~ s/\\gpgradezero{(.*?)}/\\left\\langle{$1}\\right\\rangle/g;
#   $out =~ s/\\gpgradeone{(.*?)}/{\\left\\langle{$1}\\right\\rangle}_{1}/g;
#   $out =~ s/\\gpgradetwo{(.*?)}/{\\left\\langle{$1}\\right\\rangle}_{2}/g;
#   $out =~ s/\\gpgradethree{(.*?)}/{\\left\\langle{$1}\\right\\rangle}_{3}/g;
   $out =~ s/\\gpgradezero${r1}/\\left\\langle{$1}\\right\\rangle/g;
   $out =~ s/\\gpgradeone${r1}/{\\left\\langle{$1}\\right\\rangle}_{1}/g;
   $out =~ s/\\gpgradetwo${r1}/{\\left\\langle{$1}\\right\\rangle}_{2}/g;
   $out =~ s/\\gpgradethree${r1}/{\\left\\langle{$1}\\right\\rangle}_{3}/g;
   $out =~ s/\\gpgradefour${r1}/{\\left\\langle{$1}\\right\\rangle}_{4}/g;

   $out =~ s/\\rgrad/\\stackrel{ \\rightarrow }\\grad/g;
   $out =~ s/\\lgrad/\\stackrel{ \\leftarrow }\\grad/g;
   $out =~ s/\\lrgrad/\\stackrel{ \\leftrightarrow }\\grad/g;
   $out =~ s/\\lrpartial/\\stackrel{ \\leftrightarrow }\\partial/g;
   $out =~ s/\\rspacegrad/\\stackrel{ \\rightarrow }\\spacegrad/g;
   $out =~ s/\\lspacegrad/\\stackrel{ \\leftarrow }\\spacegrad/g;

   $out =~ s/\\BCB/\\boldsymbol{\\mathcal{B}}/g;
   $out =~ s/\\EE/\\boldsymbol{\\mathcal{E}}/g;
   $out =~ s/\\kcap/\\hat{\\Bk}/g;
   $out =~ s/\\xcap/\\hat{\\Bx}/g;
   $out =~ s/\\ncap/\\hat{\\Bn}/g;
   $out =~ s/\\Bomega/\\boldsymbol{\\omega}/g;
   $out =~ s/\\Bsigma/\\boldsymbol{\\sigma}/g;
   $out =~ s/\\Brho/\\boldsymbol{\\rho}/g;
   $out =~ s/\\(.)cap/\\hat{\\B$1}/g;
   $out =~ s/\\B(.)/\\mathbf{$1}/g;
   $out =~ s/\\LL/\\mathcal{L}/g;
   $out =~ s/\\FF/\\mathcal{F}/g;
   $out =~ s/\\cross/\\times/g;
   $out =~ s/\\grad/\\nabla/g;
   $out =~ s/\\spacegrad/\\boldsymbol{\\nabla}/g;
   $out =~ s/\\delambertian/\\square/g;
   $out =~ s/\\conj/{*}/g;

   $out =~ s,\\PDi${r2},{\\partial $2}/{\\partial $1},g ;

   $out =~ s/\\PD${r2}/\\frac{\\partial $2}{\\partial $1}/g ;
   $out =~ s/\\PauliI/\\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ \\end{bmatrix}/g;
   $out =~ s/\\PauliX/\\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\\\ \\end{bmatrix}/g;
   $out =~ s/\\PauliYNoI/\\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\\\ \\end{bmatrix}/g;
   $out =~ s/\\PauliY/\\begin{bmatrix} 0 & -i \\\\ i & 0 \\\\ \\end{bmatrix}/g;
   $out =~ s/\\PauliZ/\\begin{bmatrix} 1 & 0 \\\\ 0 & -1 \\\\ \\end{bmatrix}/g;
   $out =~ s/\\Clifford{(.*?)}{(.*?)}/\\mathcal{C}_{\\{{$1},{$2}\\}}/g;
   $out =~ s/\\scalarProduct{(.*?)}{(.*?)}/{$1} \\bullet {$2}/g;

#   $out =~ s/\\antisymmetric{(.*?)}{(.*?)}/\\left[{$1},{$2}\\right]/g;
#   $out =~ s/\\symmetric{(.*?)}{(.*?)}/\\left\\{{$1},{$2}\\right\\}/g;

# run twice?
   $out =~ s/\\antisymmetric${r2}/\\left[$1,$2\\right]/g;
   $out =~ s/\\symmetric${r2}/\\left\\{$1,$2\\right\\}/g;

   $out =~ s/\\antisymmetric${r2}/\\left[$1,$2\\right]/g;
   $out =~ s/\\symmetric${r2}/\\left\\{$1,$2\\right\\}/g;

   $out =~ s/\\DETuvwijk{(.*?)}{(.*?)}{(.*?)}{(.*?)}{(.*?)}{(.*?)}/\\begin{vmatrix} {$1}_{$4} & {$1}_{$5} & {$1}_{$6} \\\\ {$2}_{$4} & {$2}_{$5} & {$2}_{$6} \\\\ {$3}_{$4} & {$3}_{$5} & {$3}_{$6} \\end{vmatrix}/g;

   $out =~ s/\\C{(.*?)}/$latexDollarStart\\mathbb{C}^{$1}\$/g;
   $out =~ s/\\R{(.*?)}/$latexDollarStart\\mathbb{R}^{$1}\$/g;
   $out =~ s/\\traceB${r1}/\\tr\\left({$1}\\right)/g;
   $out =~ s/\\trace${r1}/\\tr{$1}/g;
   $out =~ s/\\tr/\\text{Tr}/g;
   $out =~ s/\\RejName/\\text{Rej}/g;
   $out =~ s/\\Proj/\\text{Proj}/g;
   $out =~ s/\\Scalar/\\text{Scalar}/g;
   $out =~ s/\\Real/\\text{Real}/g;
   $out =~ s/\\Imag/\\text{Imag}/g;
   $out =~ s/\\symmetricVecBladePauli{(.*?)}{(.*?)}{(.*?)}/\\left\\{{$1},\\left[{$2},{$3}\\right]\\right\\}/g;
   $out =~ s/\\symmetricBladeVecPauli{(.*?)}{(.*?)}{(.*?)}/\\left\\{\\left[{$1},{$2}\\right],{$3}\\right\\}/g;
   $out =~ s/\\ahat/\\hat{a}/g;
   $out =~ s/\\bhat/\\hat{b}/g;
   $out =~ s/\\xhat/\\hat{x}/g;
   $out =~ s/\\thetacap/\\hat{\\boldsymbol{\\theta}}/g;
   $out =~ s/\\phicap/\\hat{\\boldsymbol{\\phi}}/g;
   $out =~ s/\\questionEquals/\\stackrel{?}{=}/g;
   $out =~ s/\\T\b/\\text{T}/g;

   if ( $mathml )
   {
      $out =~ s/\\text/\\textrm/g;

      $out =~ s/\\lvert/\\left\\vert/g ;
      $out =~ s/\\rvert/\\right\\vert/g ;

      # hack.  Not supported by the script.
      $out =~ s/\\boldsymbol//g ;
   }

   return $out ;
}

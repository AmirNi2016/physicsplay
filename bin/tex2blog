#! /usr/bin/perl
# $Log: tex2blog,v $
# Revision 1.12  2009/08/29 19:08:31  Peeter
# *** empty log message ***
#
# Revision 1.11  2009/08/09 04:43:49  Peeter
# *** empty log message ***
#
# Revision 1.10  2009/07/11 04:53:16  Peeter
# *** empty log message ***
#
# Revision 1.9  2009/07/09 03:17:51  Peeter
# *** empty log message ***
#

use strict ;
use warnings ;
use Getopt::Long;

my $filebase ;
my $showNumbers = 1 ;

GetOptions( 
   'file=s'    => \$filebase,
   'num!'      => \$showNumbers,
) ;

my $fh ;
my %equations ;

#foreach (<light*>)
#{
#print "$_\n" ;
#}
#my $pwd = `pwd` ; chomp $pwd ;
#print "pwd: $pwd\n" ;

open $fh, "<$filebase.aux" or die "could not open '$filebase.aux'\n" ;
while (<$fh>)
{
   if ( /^\\newlabel{(.*?)}.*equation\.(.*?)}/ )
   {
      $equations{$1} = $2 ;
   }
}
close $fh ;

my $bibString = '' ;
my %refnumbers ;
my $curNum = 1 ;
my $haveBib = 1 ;
open $fh, "<$filebase.bbl" or $haveBib = 0 ;

if ( $haveBib )
{
   while (<$fh>)
   {
      chomp ;

      s,\\begin{thebibliography}.*,<h1>References</h1>, ;

#\bibitem[Joot({\natexlab{a}})]{PJLorentzWave}
      s/\\bibitem.*]{/\\bibitem{/ ;
      if ( s/\\bibitem{(.*?)}// )
      {
         $bibString .= "\n\n" ;
         $refnumbers{$1} = $curNum ;
         $bibString .= "[$curNum] " ;

         $curNum++ ;
      }
      else
      {
         next if (/Available from:/ or
                  /\\providecommand/ or
                  /\\expandafter/ or
                  0 ) ;

         if ( /\\end{thebibliography}/ )
         {
            $bibString =~ s,\\url{(.*?)},<a href="$1">$1</a>,;
            $bibString .= "\n" ;
            last ;
         }

         s/~/ /g ;
         s,{ *\\em\s+(.*?)},<em>$1</em>,g;
         s,\\em *{(.*?)},<em>$1</em>,g ;
         s,\\emph *{(.*?)},<em>$1</em>,g ;
         s/\\newblock// ;

# \url can be split across lines, as in the following:
#  \url{http://en.wikipedia.org/w/index.php?title=Relativistic_Doppler_effect&o%
#ldid=298724264}.
#
#In case it isn't do a first check here before stripping out {}'s
#
         s,\\url{(.*?)},<a href="$1">$1</a>,sg;
         s/{(.*?)}/$1/g ;

#die "'$_'\n" if /\\url/ ;
         $bibString .= "$_" ;
      }
   }

   close $fh ;
}

my $curEqn = '' ;
my $curEquationLabel = '' ;
my $inEquation = 0 ;
my $failedOpen ;
#my $urlMessage = "Click here for a PDF of this post with nicer formatting" ;
my $urlMessage = "Click here for a PDF of this sequence of posts with nicer formatting" ;
open $fh, "<$filebase.tex" or $failedOpen = 1 ;
if ( $failedOpen )
{
   open $fh, "<$filebase.ltx" or die "could not open '$filebase.tex' nor '$filebase.ltx'\n" ;
}
while (<$fh>)
{
   chomp ;
   s/\\cite{(.*?)}/[$refnumbers{$1}]/g;
   s/%.*//;
   s,\\blogpage{(.*)},<a href="$1">[$urlMessage]</a>,;

next if (
/\\begin{document}/ or
/\\end{document}/ or
/\\maketitle/ or
/\\tableofcontents/ or
/\\usepackage/ or
/\\newcommand/ or
/\\documentclass/ or
/\\title/ or
/\\email/ or
/\\date/ or
/\\author/ or
/\\revisionInfo/ or
/\\input/ or
/\\bibliography/ or
/\\beginArtWithToc/ or
/\\EndArticle/ or
/\\EndNoBibArticle/ or
/\\beginArtNoToc/ or
0 ) ;

   while ( s/\$(.*?)\$/BBB:$1:EEE/g )
   {
   }
   s/BBB:/\$latex /g;
   s/:EEE/\$/g;

   s/\\ref{(eqn:.*?)}/$equations{$1}/g ;

   s,\\section{(.*)},<h1>$1</h1>,;
   s,\\subsection{(.*)},<h2>$1</h1>,;
   s,\\subsubsection{(.*)},<h3>$1</h1>,;
   s,\\href{(.*?)}{(.*?)},<a href="$1">$2</a>,g ;

   if ( s/\\begin{align\**}// or s/\\begin{equation\**}// )
   {
      if ( s/\\label{(eqn:.*?)}// and $showNumbers )
      {
         $curEquationLabel = "\\quad\\quad\\quad($equations{$1})" ;
      }
      $curEqn .= $_ ;
      $inEquation = 1 ;
   }
   elsif ( s/\\end{align\**}.*// or s/\\end{equation\**}.*// )
   {
# sample output from latex2wp.  centers things ... looks a bit nicer.
#<p align=center>$latex \displaystyle   \forall g \in {\cal F}. g^2 = \eta \ \ \ \ \ (1)&fg=000000$</p>

      my $eq = '<p align=center>$latex \\begin{aligned}' . translate( "$curEqn$_" ) ;
      $eq =~ s/ *\\\\ *$//g;

# latex2wp used this, but I don't see a difference:
      my $fgString = '' ;
#      $fgString = "&fg=000000" ; # omit.

      $eq .= " \\end{aligned} $curEquationLabel$fgString\$</p>\n" ;
      print $eq ;
      $curEqn = '' ;
      $inEquation = 0 ;
      $curEquationLabel = '' ;
   }
   elsif ( $inEquation )
   {
      $curEqn .= $_ ;
   }
   else
   {
      s/\\label{(.*?)}//g;

      print translate( $_ ) . "\n" ;
   }
}
close $fh ;

print $bibString ;

exit ;

sub translate
{
   my $r1 = qr/
        (                   # start of capture buffer 1
        {                   # match an opening angle bracket
            (?:               
                [^{}]++     # one or more non angle brackets, non backtracking
                  |                  
                (?1)        # found { or }, so recurse to capture buffer 1
            )*                 
        }                   # match a closing angle bracket
        )                   # end of capture buffer 1
        /x;

   my $r2 = qr/
        (                   # start of capture buffer 1
        {                   # match an opening angle bracket
            (?:               
                [^{}]++     # one or more non angle brackets, non backtracking
                  |                  
                (?1)        # found { or }, so recurse to capture buffer 1
            )*                 
        }                   # match a closing angle bracket
        )                   # end of capture buffer 1
        (                   # start of capture buffer 1
        {                   # match an opening angle bracket
            (?:               
                [^{}]++     # one or more non angle brackets, non backtracking
                  |                  
                (?1)        # found { or }, so recurse to capture buffer 1
            )*                 
        }                   # match a closing angle bracket
        )                   # end of capture buffer 1
        /x;


   my $out = "@_" ;

   $out =~ s/\\\\/\\\\ /g;
#   $out =~ s/&=/=/g;

   # convert some of my macros:
   #$out =~ s/\\inv{(.*?)}/\\frac{1}{$1}/g;
   $out =~ s/\\inv${r1}/\\frac{1}{$1}/g;
   #$out =~ s/\\Abs{(.*?)}/{\\left\\lvert{$1}\\right\\rvert}/g;
   $out =~ s/\\Abs${r1}/{\\left\\lvert$1\\right\\rvert}/g;
   $out =~ s/\\gpgrade${r2}/{\\left\\langle{$1}\\right\\rangle}_{$2}/g;

#   $out =~ s/\\gpgradezero{(.*?)}/\\left\\langle{$1}\\right\\rangle/g;
#   $out =~ s/\\gpgradeone{(.*?)}/{\\left\\langle{$1}\\right\\rangle}_{1}/g;
#   $out =~ s/\\gpgradetwo{(.*?)}/{\\left\\langle{$1}\\right\\rangle}_{2}/g;
#   $out =~ s/\\gpgradethree{(.*?)}/{\\left\\langle{$1}\\right\\rangle}_{3}/g;
   $out =~ s/\\gpgradezero${r1}/\\left\\langle{$1}\\right\\rangle/g;
   $out =~ s/\\gpgradeone${r1}/{\\left\\langle{$1}\\right\\rangle}_{1}/g;
   $out =~ s/\\gpgradetwo${r1}/{\\left\\langle{$1}\\right\\rangle}_{2}/g;
   $out =~ s/\\gpgradethree${r1}/{\\left\\langle{$1}\\right\\rangle}_{3}/g;

   $out =~ s/\\rgrad/\\stackrel{ \\rightarrow }\\grad/g;
   $out =~ s/\\lgrad/\\stackrel{ \\leftarrow }\\grad/g;
   $out =~ s/\\lrgrad/\\stackrel{ \\leftrightarrow }\\grad/g;
   $out =~ s/\\rspacegrad/\\stackrel{ \\rightarrow }\\spacegrad/g;
   $out =~ s/\\lspacegrad/\\stackrel{ \\leftarrow }\\spacegrad/g;

   $out =~ s/\\BCB/\\boldsymbol{\\mathcal{B}}/g;
   $out =~ s/\\EE/\\boldsymbol{\\mathcal{E}}/g;
   $out =~ s/\\kcap/\\hat{\\Bk}/g;
   $out =~ s/\\xcap/\\hat{\\Bx}/g;
   $out =~ s/\\ncap/\\hat{\\Bn}/g;
   $out =~ s/\\Bomega/\\boldsymbol{\\omega}/g;
   $out =~ s/\\Bsigma/\\boldsymbol{\\sigma}/g;
   $out =~ s/\\Brho/\\boldsymbol{\\rho}/g;
   $out =~ s/\\(.)cap/\\hat{\\B$1}/g;
   $out =~ s/\\B(.)/\\mathbf{$1}/g;
   $out =~ s/\\LL/\\mathcal{L}/g;
   $out =~ s/\\FF/\\mathcal{F}/g;
   $out =~ s/\\cross/\\times/g;
   $out =~ s/\\grad/\\nabla/g;
   $out =~ s/\\spacegrad/\\boldsymbol{\\nabla}/g;
   $out =~ s/\\delambertian/\\square/g;
   $out =~ s/\\conj/{*}/g;
   $out =~ s/\\PD${r2}/\\frac{\\partial $2}{\\partial $1}/g ;
   $out =~ s/\\PauliI/\\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ \\end{bmatrix}/g;
   $out =~ s/\\PauliX/\\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\\\ \\end{bmatrix}/g;
   $out =~ s/\\PauliYNoI/\\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\\\ \\end{bmatrix}/g;
   $out =~ s/\\PauliY/\\begin{bmatrix} 0 & -i \\\\ i & 0 \\\\ \\end{bmatrix}/g;
   $out =~ s/\\PauliZ/\\begin{bmatrix} 1 & 0 \\\\ 0 & -1 \\\\ \\end{bmatrix}/g;
   $out =~ s/\\Clifford{(.*?)}{(.*?)}/\\mathcal{C}_{\\{{$1},{$2}\\}}/g;
   $out =~ s/\\scalarProduct{(.*?)}{(.*?)}/{$1} \\bullet {$2}/g;

#   $out =~ s/\\antisymmetric{(.*?)}{(.*?)}/\\left[{$1},{$2}\\right]/g;
#   $out =~ s/\\symmetric{(.*?)}{(.*?)}/\\left\\{{$1},{$2}\\right\\}/g;

# run twice?
   $out =~ s/\\antisymmetric${r2}/\\left[$1,$2\\right]/g;
   $out =~ s/\\symmetric${r2}/\\left\\{$1,$2\\right\\}/g;

   $out =~ s/\\antisymmetric${r2}/\\left[$1,$2\\right]/g;
   $out =~ s/\\symmetric${r2}/\\left\\{$1,$2\\right\\}/g;

   $out =~ s/\\DETuvwijk{(.*?)}{(.*?)}{(.*?)}{(.*?)}{(.*?)}{(.*?)}/\\begin{vmatrix} {$1}_{$4} & {$1}_{$5} & {$1}_{$6} \\\\ {$2}_{$4} & {$2}_{$5} & {$2}_{$6} \\\\ {$3}_{$4} & {$3}_{$5} & {$3}_{$6} \\end{vmatrix}/g;

   $out =~ s/\\C{(.*?)}/\$latex \\mathbb{C}^{$1}\$/g;
   $out =~ s/\\R{(.*?)}/\$latex \\mathbb{R}^{$1}\$/g;
   $out =~ s/\\traceB${r1}/\\tr\\left({$1}\\right)/g;
   $out =~ s/\\trace${r1}/\\tr{$1}/g;
   $out =~ s/\\tr/\\text{Tr}/g;
   $out =~ s/\\RejName/\\text{Rej}/g;
   $out =~ s/\\Proj/\\text{Proj}/g;
   $out =~ s/\\Scalar/\\text{Scalar}/g;
   $out =~ s/\\Real/\\text{Real}/g;
   $out =~ s/\\Imag/\\text{Imag}/g;
   $out =~ s/\\symmetricVecBladePauli{(.*?)}{(.*?)}{(.*?)}/\\left\\{{$1},\\left[{$2},{$3}\\right]\\right\\}/g;
   $out =~ s/\\symmetricBladeVecPauli{(.*?)}{(.*?)}{(.*?)}/\\left\\{\\left[{$1},{$2}\\right],{$3}\\right\\}/g;
   $out =~ s/\\ahat/\\hat{a}/g;
   $out =~ s/\\bhat/\\hat{b}/g;
   $out =~ s/\\xhat/\\hat{x}/g;
   $out =~ s/\\thetacap/\\hat{\\boldsymbol{\\theta}}/g;
   $out =~ s/\\phicap/\\hat{\\boldsymbol{\\phi}}/g;

   return $out ;
}

#!/usr/bin/perl

#-----------------------------------------------------------------------------
# POD Format Documentation.  Read "perldoc perlpod" or see the lclient
# command for an example.  When done, check syntax with "podchecker".

=head1 NAME

myindent - run really badly formatted code through gnu-indent with some options to make it less horrible.

=head1 SYNOPSIS

<command> [<options>]

=head1 DESCRIPTION

It looks like somebody used the perl skeleton without filling in the POD
documentation for their particular script.  Shame on them!!!

=head1 SUPPORTED PLATFORMS

<delete all but one of the following>
 
 All (verified)
 All (Unix verified)
 All (Windows verified)
 Unix only
 Windows only
 <insert special value here>

=head1 SUPPORT

<delete all but one of the following, and fill in the blanks>

 Open a CQ defect against project 'latest', component <component>
 Send email to <user or group>
 None

=head1 AUTHORS

=head1 CREATION DATE

=cut

#-----------------------------------------------------------------------------

use strict;
use warnings;		# mandatory during testing
use Getopt::Long;
use Pod::Usage;

# Suppress sourcing of users' .kshrc files in invoked shells
delete $ENV{'ENV'};

# Set STDOUT and STDERR to unbuffered
select STDERR; $| = 1;
select STDOUT; $| = 1;

#declare lexical variables to be used anywhere in this script (pseudo-global)
my ($myName,$usage) = "";

($myName = $0) =~ s@.*[/\\]@@;

#GetOptions ( 
#   "help"               => sub { pod2usage(-verbose => 2); },
#) or pod2usage(-verbose => 0);

# Validate/handle options

#... handle options ...

# If appropriate, log the usage of this script.  Run "lclient -help" for usage.
#system ("lclient $myName");

use English (qw(OSNAME)) ;

my $gindent = 'indent' ;
my $flags = '' ;

#
#
#   By default `indent' will line up identifiers, in the column
#specified by the `-di' option.  For example, `-di16' makes things look
#like:
#
#     int             foo;
#     char           *bar;
#
# OSS format: what we want is:
#     int             foo;
#     char *          bar;
#
# where the spacing is a few bigger then the longest name.
#$flags .= ' --declaration-indentation16' ; 

# indent three characters:
$flags .= ' --indent-level3' ;

#The `-bl' option formats them like this:
#
#     if (x > 0)
#       {
#         x--;
#       }
#
#If you use the `-bl' option, you may also want to specify the `-bli'
#option.  This option specifies the number of spaces by which braces are
#indented.  `-bli2', the default, gives the result shown above.  `-bli0'
#results in the following:
#
#  if (x > 0)
#  {
#    x--;
#  }
$flags .= ' --braces-after-if-line' ;
$flags .= ' --brace-indent0' ;

#   The `-cli' option specifies the number of spaces that case labels
#should be indented to the right of the containing `switch' statement.
$flags .= ' --case-indentation0' ;

#   The `-brs' or `-bls' option specifies how to format braces in struct
#declarations.  The `-brs' option formats braces like this:
#
#     struct foo {
#       int x;
#     };
#
#The `-bls' option formats them like this:
#
#     struct foo
#     {
#       int x;
#     };
$flags .= ' --braces-after-struct-decl-line' ;

$flags .= ' --comment-delimiters-on-blank-lines' ;
$flags .= ' --start-left-side-of-comments' ;
$flags .= ' --blank-lines-after-procedures' ;
$flags .= ' --tab-size3' ;
$flags .= ' --dont-format-comments' ;
$flags .= ' --no-comment-delimiters-on-blank-lines' ;
$flags .= ' --start-left-side-of-comments' ;

#$flags .= ' --blank-lines-after-commas' ;
# (doesn't seem to work?)
#$flags .= ' -bc' ;

$flags .= ' --no-space-after-function-call-names' ;

foreach (@ARGV)
{
   $flags .= " $_" ;
}

open(my $file, "$gindent $flags |") || die ("couldn't preprocess file $ARGV[0]") ;

my $sl='/' ;
my $semic = ';' ;
while (<$file>)
{
   chomp ;

   s/\s+$// ;
        s/	/   /g ;
        s/$sl$sl([bde])/$sl$sl\@$1/g ;
        s/$sl\*([bde])/$sl*\@$1/g ;
        s/($sl\*[^\s]+)\s+\*$sl/$1*$sl/g ;
        s/\* \*\* /* / ;
        s/\* \* /* / ;

   my $head = $_ ;
   my $tail = "" ;

   while ( $head =~ q!(.*)/\*@(.*)!)
   {
      my ($headnew, $tailnew) = ($1, $2) ;
      $head = $headnew ;
      $tail = "/*@" . $tailnew . $tail ;
   }

   while ( $head =~ q!(.*)//@(.*)!)
   {
      my ($headnew, $tailnew) = ($1, $2) ;
      $head = $headnew ;
      $tail = "//@" . $tailnew . $tail ;
   }

   if ($tail ne "")
   {
      $head =~ s/\s+$// ;
      $tail =~ s/^\s+// ;

      $head =~ s/; *$/ ;/ ;

      my $tlen = length($tail) ;
      my $hlen = length($head) ;
      my $space = 0 ;

      if ($hlen + $tlen < 80)
      {
         $space = 80 - $hlen - $tlen ;
      }

# hhhhhh sssss ttttt

      # Note: $head (and perhaps $tail ?) can have format 
      # specifiers in them so they cant be embedded directly 
      # in the format string:
      printf ("%s%${space}s%s\n", $head, ' ', $tail) ;
   }
   else
   {
      s/; *$/ ;/ ;
      s/([^\s]);/$1 ;/ ;

      print "$_\n" ;
   }
}

close( $file ) ;

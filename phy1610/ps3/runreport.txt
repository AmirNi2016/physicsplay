1. Profile the original code ants.cc and your modular implementation (done in HW#2). For doing so, please use the following methods:

  ----------------------------------------------------------------------------------------------------- 
  a) the time command,

  Commands:

    (time ./origants) 2>&1 | tail -3 | tee time.orig.out
    (time ./ants) 2>&1 | tail -3 | tee time.mine.out

  Results:

      # mine (mine is probably a bit faster since there's a double counting of totants in the original)
      real	0m0.716s
      user	0m0.696s
      sys	0m0.000s

      # orig
      real	0m0.726s
      user	0m0.692s
      sys	0m0.000s

   Not much variation was observed between back to back measurements using time.

  ----------------------------------------------------------------------------------------------------- 
  b) Instrumenting both the original and modularized version of the code (in the places you consider appropriate) with tick-tock calls. 

   # monolithic code:

      $ USETICKTOCK=1 make origants
      g++ -DUSE_TICK_TOCK -MMD -I../inc -I../../rarray -I/home/peeterj/ticktock -DNDEBUG -O2 -Wall -Werror -std=c++11   -c -o origants.o origants.cc
      cp /home/peeterj/ticktock/ticktock.cc ticktock.cc
      g++ -DUSE_TICK_TOCK -MMD -I../inc -I../../rarray -I/home/peeterj/ticktock -DNDEBUG -O2 -Wall -Werror -std=c++11   -c -o ticktock.o ticktock.cc
      g++  -o origants origants.o  ticktock.o  

      $ ./origants | tail -4
      totants time: 	0.0044603
      init time:  	0.00213101
      core time:  	0.285268
      update time: 	0.00305058


   # modular code:

      $ USETICKTOCK=1 make ants
      g++ -DUSE_TICK_TOCK -MMD -I../inc -I../../rarray -I/home/peeterj/ticktock -DNDEBUG -O2 -Wall -Werror -std=c++11   -c -o ants.o ants.cc
      g++ -DUSE_TICK_TOCK -MMD -I../inc -I../../rarray -I/home/peeterj/ticktock -DNDEBUG -O2 -Wall -Werror -std=c++11   -c -o ticktock.o ticktock.cc
      g++ -DUSE_TICK_TOCK -MMD -I../inc -I../../rarray -I/home/peeterj/ticktock -DNDEBUG -O2 -Wall -Werror -std=c++11   -c -o ants_on_table.o ants_on_table.cc
      g++  -o ants ants.o ticktock.o ants_on_table.o  

      $ ./ants | tail -4

      totants time:   0.00463142
      init time:      0.00416679
      core time:      0.307519
      update time:    0.00398114

  Measuring a few times (10), we get:

      $ ./tickSamples
         what orig avg        orig dev          my avg          my dev         my/orig
      totants 0.004504        0.000072        0.004461        0.000066        0.990361
         init 0.002013        0.000018        0.003207        0.000075        1.593369
         core 0.288641        0.002347        0.297983        0.002639        1.032364
       update 0.003281        0.000094        0.003565        0.000222        1.086505

   Observe that the times for most of the parts of the code are all pretty comparable,
   with the exception of the fill operation, which appears to be much more expensive
   with the rarray implementation compared to the raw C++ array.  Despite that, the
   core compute loop takes the most time in either the original or the modularized
   implementation.

  ----------------------------------------------------------------------------------------------------- 
  c) and gprof (the compilation commands for gprof should also go into the Makefile).

   
$ make profile.orig.txt
rm -f gmon.out
./origants > orig.out
gprof --line --no-graph ./origants > profile.orig.txt

$ make profile.mine.txt
rm -f gmon.out
./ants > mine.out
gprof --line --no-graph ./ants > profile.mine.txt



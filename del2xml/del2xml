#!/usr/bin/perl

use strict ;
use warnings ;
use Getopt::Long ;
my $deltext ;
my $dollar ;
my $help ;

GetOptions
( 
   'delimiter=s'      => \$deltext,
   'dollar!'         => \$dollar,
   'help!'           => \$help,
) ;

if ( defined $help )
{
   print "del2xml [-help] [-delimiter blah] [-dollar]\n" .
         "\n" .
         "Options:\n" .
         "\t-dollar\tUse '\$' as a delimiter.\n" .
         "\t-delimiter blah\tUse 'blah' as a delimiter.\n" .
         "\n" .
         "Default delimiter is '[opt-spaces],[opt-spaces]\n" .
         "" ;

   exit 1 ;
}

my $delimiter ;
if ( defined $dollar )
{
   $delimiter = qr(\$) ;
}
elsif ( defined $deltext )
{
   $delimiter = qr($deltext) ;
}
else
{
   $delimiter = qr(\s*,\s*) ; # opt-spaces comma opt-spaces
}

my @headers ;
my $numTags ;
print q(<?xml version="1.0" encoding="utf-8"?>
<DataSet xmlns="http://www.ibm.com/qmf" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">

<ResultSet>
) ;

while ( <> )
{
   chomp ; # take off the trailing newline character.

   my @e = split( $delimiter, $_ ) ;
   my $numColumns = scalar( @e ) ; 

   if ( defined $numTags )
   {
      die "numColumns != numTags: $numColumns, $numTags\n" if ( $numColumns != $numTags ) ;

      print "<line>\n" ;
      for ( my $i = 0 ; $i < $numColumns ; $i++ )
      {
         print "<$headers[$i]>$e[$i]</$headers[$i]>\n" ;
      }
      print "</line>\n" ;
   }
   else
   {
      @headers = @e ;
      $numTags = $numColumns ;
   }
}
print "</ResultSet>\n" ;
